//module that does the parsin of the tcp stream into headers and the file


module.exports = function parseHeader(stream, callback) {
  
    stream.on('error', callback); //adding a listener for error
    stream.on('readable', onReadable); //adding a listener for readable event. //when a chunk of data is available in non-flowing mode
  
    var StringDecoder = require('string_decoder').StringDecoder;
    var decoder = new StringDecoder('utf8'); //a new instance of string decoder
    var header = ''; //the header string, as we read the header, it will be appended to this array
  
  function onReadable() {
    
    var chunk;
    
    while (null !== (chunk = stream.read())) {  //we're explicity calling stream.read() since it is in non-flowing mode, to read the chunk of data
      
        var str = decoder.write(chunk); //We're decoding the buffer into a string
      
      if (str.match(/\n\n/)) {  //We're looking for /n/n in the chunk of data, as the header and body is seperated by /n/n
        // found the header boundary
        
        var split = str.split(/\n\n/); //we're splitting the string into two at the /n/n and storing it in the array split.

        header += split.shift(); //What array.shift() does is that, it removes the first element of the array and then shifts the array one place to the left.
        //the zeroth element is then returned.

        var remaining = split.join('\n\n'); //It simply rejoins the remaining part of the string str, which was split by '/n/n' first,
        //here we simply joins them by '/n/n'

        var buf = new Buffer(remaining, 'utf8');//We're converting the remaining string into buffer, so that we could
        //push it back into the stream

        if (buf.length)

          stream.unshift(buf); //pushing it back into the stream

        stream.removeListener('error', callback); //error listener is removed
        stream.removeListener('readable', onReadable); //readable listener is removed, so that it can go back to flowing mode
        // now the body of the message can be read from the stream.
        
        callback(null, header, stream); //we now give the header, and the stream to the callback, which can read the remaining information
      
      } else { //if no '/n/n' is found, then the whole chunk is header info only, and more header info could be present in 
             //the following chunks.  
        // still reading the header.
        header += str;
      }
    }
  }
}

